#include <ros/ros.h>
#include "pr2_moveit_ltl/task_queue_msg.h"
#include "pr2_moveit_ltl/proposition.h"
#include "pr2_moveit_ltl/area_proposition.h"
#include "pr2_moveit_ltl/limit.h"
#include "pr2_moveit_ltl/automaton.h"
#include "pr2_moveit_ltl/transition.h"
#include "pr2_moveit_ltl/state.h"
#include "geometry_msgs/Point.h"

/*
* Clase que genera un plan de alto nivel.
*/

class PlanGen
{
private:
  pr2_moveit_ltl::area_proposition areas[3];
  pr2_moveit_ltl::automaton automata;
  pr2_moveit_ltl::proposition plan_path;
  pr2_moveit_ltl::area_proposition* pareas;
  pr2_moveit_ltl::automaton* pautomata;
  pr2_moveit_ltl::proposition* pplan_path;
  
public:
  
  PlanGen() 
  {
    pareas = areas;
    pautomata = automata;
    pplan_path = plan_path;
    
    inicializar_areas(pareas);
    //inicializar_automata(pautomata, pareas);
    //setPlan(pautomata, pareas, pplan_path);
  }

  ~PlanGen()
  {
   
  }

  void setPlan(pr2_moveit_ltl::automaton &automata, pr2_moveit_ltl::area_proposition &ars, pr2_moveit_ltl::proposition &plan)
  {
    // Solucion
		std::vector<int> area_path;
		int edo_act = 0;
		int walk = 20;
		int i = 0;
		//Usar automata para generar plan
		bool end_path = false;
		while(!end_path || i < walk){
			pr2_moveit_ltl::state aux = automata.states.at(edo_act);
			if (!aux.is_acceptance_state){
				pr2_moveit_ltl::transition aux1 = aux.transitions.at(0);
				area_path.push_back(aux1.trans_alphabet.at(0).id);
				edo_act = aux1.final_stage;
				i++;
				ROS_INFO("Aqui");
			}else{
				end_path = true;
			}
		}
	
		if(end_path){
			for(int j = 0; j < i; j++){
				pr2_moveit_ltl::proposition *pro;
  			pro->name = "Walking";
  			pro->routine="NULL";
  			pro->DOF = 3;
  			pro->point.x = ars[area_path.at(j)].limits[0].min;
  			pro->point.y = ars[area_path.at(j)].limits[1].min;
  			pro->point.z = 0.0;
  			pro->dtimes = 5;
  		
  			res.propositions.push_back(&pro);
			}
  	}
  }
  
  void getPlan(pr2_moveit_ltl::proposition &plan)
  {
    plan = plan_path;
  }
  
  void inicializar_areas(pr2_moveit_ltl::area_proposition &ars){
  	pr2_moveit_ltl::area_proposition area_0;
  	area_0.name_a = "P0";
  	area_0.alias_a = "The rest";
		area_0.id = 0;
		area_0.name_mg = "base";
		area_0.DOF_mg = 3;
	
		pr2_moveit_ltl::limit lim_0_1;
		lim_0_1.min = -5.0;
		lim_0_1.max = 5.0;
	
		pr2_moveit_ltl::limit lim_0_2;
		lim_0_2.min = -5.0;
		lim_0_2.max = 5.0;
	
		pr2_moveit_ltl::limit lim_0_3;
		lim_0_3.min = -3.14;
		lim_0_3.max = 3.14;
	
		area_0.limits.push_back(lim_0_1);
		area_0.limits.push_back(lim_0_2);
		area_0.limits.push_back(lim_0_3);
		
  	pr2_moveit_ltl::area_proposition area_1;
		area_1.name_a = "P1";
		area_1.alias_a = "Kitchen";
		area_1.id = 1;
		area_1.name_mg = "base";
		area_1.DOF_mg = 3;
	
		pr2_moveit_ltl::limit lim_1_1;
		lim_1_1.min = 0.9;
		lim_1_1.max = 1.1;
	
		pr2_moveit_ltl::limit lim_1_2;
		lim_1_2.min = 3.8;
		lim_1_2. max = 4.2;
	
		pr2_moveit_ltl::limit lim_1_3;
		lim_1_3.min = -3.14;
		lim_1_3.max = 3.14;
	
		area_1.limits.push_back(lim_1_1);
		area_1.limits.push_back(lim_1_2);
		area_1.limits.push_back(lim_1_3);
	
		pr2_moveit_ltl::area_proposition area_2;
		area_2.name_a = "P2";
		area_2.alias_a = "Living";
		area_2.id = 2;
		area_2.name_mg = "base";
		area_2.DOF_mg = 3;
		
		pr2_moveit_ltl::limit lim_2_1;
		lim_2_1.min = -4.1;
		lim_2_1.max = -3.8;
	
		pr2_moveit_ltl::limit lim_2_2;
		lim_2_2.min = -4.1;
		lim_2_2.max = -3.8;
	
		pr2_moveit_ltl::limit lim_2_3;
		lim_2_3.min = -3.14;
		lim_2_3.max = 3.14;
	
		area_2.limits.push_back(lim_2_1);
		area_2.limits.push_back(lim_2_2);
		area_2.limits.push_back(lim_2_3);

  	int i = 0;

		for(std::vector<pr2_moveit_ltl::area_proposition>::const_iterator it = ars->begin(); it != ars->end(); ++it)
		{
		  if(i == 0){
		  	*it = area_0;
		  }
		  
		  if(i == 1){
		  	*it = area_1;
		  }
		  
		  if(i == 2){
		    *it = area_2;
		  }
			
			i++;
		}
  }
  
  void inicializar_automata(pr2_moveit_ltl::automaton &automata, pr2_moveit_ltl::area_proposition &ars){
  	//Automata
		//pr2_moveit_ltl::automaton automata;
		automata.name = "Simple_Action";
		automata.id = 1;
		
		pr2_moveit_ltl::area_proposition area[3];
		int i = 0;
		for(std::vector<pr2_moveit_ltl::area_proposition>::const_iterator it = ars->begin(); it != ars->end(); ++it)
		{
		  area[i] = *it;
			i++;
		}
		//Agregar las areas al alfabeto
		automata.alphabet.push_back(area[0]);
		automata.alphabet.push_back(area[1]);
		automata.alphabet.push_back(area[2]);
	
		pr2_moveit_ltl::state sta0;
		sta0.name = "Edo0";
		sta0.id= 0;
		sta0.is_initial_state = true;
		sta0.is_acceptance_state = false;
		sta0.valid_propositions.push_back(area[0]);
		sta0.valid_propositions.push_back(area[1]);
		sta0.valid_propositions.push_back(area[2]);
		
		pr2_moveit_ltl::transition trans0_0;
		trans0_0.name = "Trans edo 0 0";
		trans0_0.id = 0;
		trans0_0.initial_stage = 0;
		trans0_0.final_stage = 1;
		trans0_0.trans_alphabet.push_back(area[1]);
	
		pr2_moveit_ltl::transition trans0_1;
		trans0_1.name = "Trans edo 0 1";
		trans0_1.id = 1;
		trans0_1.initial_stage = 0;
		trans0_1.final_stage = 0;
		trans0_1.trans_alphabet.push_back(area[2]);
		trans0_1.trans_alphabet.push_back(area[0]);
	
		sta0.transitions.push_back(trans0_0);
		sta0.transitions.push_back(trans0_1);
	
		pr2_moveit_ltl::state sta1;
		sta1.name = "Edo1";
		sta1.id= 1;
		sta1.is_initial_state = false;
		sta1.is_acceptance_state = false;
		sta1.valid_propositions.push_back(area[0]);
		sta1.valid_propositions.push_back(area[1]);
		
		pr2_moveit_ltl::transition trans1_0;
		trans1_0.name = "Trans edo 1 0";
		trans1_0.id = 10;
		trans1_0.initial_stage = 1;
		trans1_0.final_stage = 2;
		trans1_0.trans_alphabet.push_back(area_2);
		
		pr2_moveit_ltl::transition trans1_1;
		trans1_1.name = "Trans edo 1 1";
		trans1_1.id = 11;
		trans1_1.initial_stage = 1;
		trans1_1.final_stage = 1;
		trans1_1.trans_alphabet.push_back(area[1]);
		trans1_1.trans_alphabet.push_back(area[0]);
		
		sta1.transitions.push_back(trans1_0);
		sta1.transitions.push_back(trans1_1);
		
		pr2_moveit_ltl::state sta2;
		sta2.name = "Edo2";
		sta2.id= 2;
		sta2.is_initial_state = false;
		sta2.is_acceptance_state = true;
		sta2.valid_propositions.push_back(area[2]);
	
		automata.states.push_back(sta0);
		automata.states.push_back(sta1);
		automata.states.push_back(sta2);
	
		automata.initial_state = sta0;
		automata.acceptance_states.push_back(sta2);
  }
};

bool generate_task(pr2_moveit_ltl::task_queue_msg::Request  &req,
         pr2_moveit_ltl::task_queue_msg::Response &res)
{
  PlanGen planeador;
  res.size = 0;
  planeador.getPlan(res.propositions);
	
  return true;
}

int main(int argc, char **argv){
	ros::init(argc, argv, "plan_gen_ltl");
	ros::NodeHandle n;

	ros::ServiceServer service = n.advertiseService("plan_gen_ltl", generate_task);
  ROS_INFO("Ready to generate plan (task queue).");
  ros::spin();

  return 0;
}

